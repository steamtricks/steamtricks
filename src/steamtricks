#!/usr/bin/env bash

#
# steamtricks provides workarounds for problems with Steam on Linux
#

# build-time constants
STEAMTRICKS_VERSION="development"
STEAMTRICKS_SCRIPT="$(cd "${0%/*}" && echo "$PWD")/${0##*/}"
STEAMTRICKS_DIR="$(dirname "$STEAMTRICKS_SCRIPT")"
STEAMTRICKS_DATA_DIR=/usr/share/steamtricks
STEAMTRICKS_DATA_REPO_DIR="$STEAMTRICKS_DATA_DIR/data"
CONFIG_DIR=~/.local/share/steamtricks
CONFIG_RC="$CONFIG_DIR/steamtricksrc"
CONFIG_CACHE_DIR="$CONFIG_DIR/cache"
PID_FILE="$CONFIG_DIR/.steamtrickspid"
STEAM_LIB_PREFIX=/usr/lib/steam
STEAM_OPENSSL_REPLACE=1
STEAM_DIR=~/.local/share/Steam
STEAM_RUNTIME=$STEAM_DIR/ubuntu12_32/steam-runtime

# config defaults
C_DATA_DIR=
C_NOTIFICATION=1
C_NOTIFICATION_CLEAN=1
C_NOTIFICATION_FIX_APPLY=1
C_NOTIFICATION_FIX_APPLY_NONE=1
C_NOTIFICATION_FIX_APPLY_PRE=1
C_NOTIFICATION_FIX_FETCH=1
C_STEAM_STARTUP_TIMEOUT_MAX_SECS=120

_C_VERSION=20161006


C_DEBUG=1


debug_output()
{
  if test "$C_DEBUG" == 1; then
   (>&2 echo "Debug: $1")
  fi
}

notify()
{
  echo "notify: $2"
  eval local toggle=\$$"C_NOTIFICATION_$1"
  if test "$C_NOTIFICATION" == 1 && test "$toggle" == 1 ; then
    notify-send "steamtricks" "$2" --icon=steam
  fi
}

strip_quotes()
{
  local clean="$1"
  clean="${clean%\"}"
  clean="${clean#\"}"
  echo "$clean"
}

keyvalue_parse()
{
  local file="$1"
  local match="$2"

  local section=()
  local previous
  local previous_consumed=0
  local IFS=$'\t\n'
  for line in $(< "$file") ; do
    line=$(strip_quotes "$line")
    case $line in
      \{) section+=("$previous") ;;
      \}) unset section[${#section[@]}-1] ;;
      *)
      if [[ "$previous" != "" && "$previous" != "{" && "$previous" != "}" ]] ; then
        if [ $previous_consumed -eq 1 ] ; then
          previous_consumed=0
        else
          IFS='_'; echo "${section[*]}_$previous='$line'"
          previous_consumed=1
        fi
      fi
      ;;
    esac
    previous=$line
  done
}

steam_library_directories()
{
  echo "parsing libraryfolders.vdf..." >&2
  echo "$STEAM_DIR/steamapps"
  (
    eval $(keyvalue_parse "$STEAM_DIR/steamapps/libraryfolders.vdf")
    for var in $(compgen -A variable | grep -E "LibraryFolders_[0-9]+$") ; do
      eval echo \$$var/steamapps
    done
  )
}

steam_app_manifest()
{
  local app_id=$1
  local manifest
  local IFS=$'\n' # allow for spaces in directories
  for dir in $(steam_library_directories) ; do
    manifest="$dir/appmanifest_$app_id.acf"
    if [ -f "$manifest" ] ; then
      echo "$manifest"
      break
    fi
  done
}

steamtricks_fix_fetch()
{
  notify FIX_FETCH "fetching fix for app $1"
}

steamtricks_fix_apply()
{
  local app_id=$1
  local manifest=$(steam_app_manifest $app_id)
  if [[ -z "$manifest" ]] ; then
    echo "no manifest found for app $app_id"
    return 1
  fi

  eval $(keyvalue_parse "$manifest")
  local app_name="$AppState_name"
  local app_dir="$(dirname "$manifest")/common/$AppState_installdir"

  notify FIX_APPLY_PRE "Handling <b>$app_name</b> update"

  local failed=0
  local removed=$(remove_incompatible_files "$app_dir")
  local applied=0

  cd "$app_dir"
  if [ ! $? -eq 0 ] ; then
    echo "unable to enter app_dir"
    return 1
  fi

  local data_dir="$STEAMTRICKS_DATA_REPO_DIR/$app_id-*"
  data_dir=$(echo $data_dir) # evaluate the glob
  if [ -d "$data_dir" ] ; then
    echo "fix available"

    streamtricks_fix_script "$data_dir/00-pre"
    if [ $? -eq 1 ] ; then
      failed=1
    fi

    if [ -f "$data_dir/00-remove" ] ; then
      ((removed+=$(rm -v $(cat "$data_dir/00-remove") | tee /dev/stderr | wc -l)))
      failed=$?
    fi

    # could pipe the list of patches, but loose access to variable state
    local IFS=$'\n' # allow for spaces in directories
    for patch in $(find "$data_dir" -type f -name "*.patch") ; do
      echo "patch $patch..."
      patch -p1 --dry-run --unified --forward -i "$patch"
      if [ $? -eq 0 ] ; then
        patch -p1 --unified --forward -i "$patch"
      else
        patch -t -p1 --dry-run --unified --reverse -i "$patch"
      fi

      if [ $? -eq 0 ] ; then
        ((applied++))
      else
        failed=1
      fi
    done

    streamtricks_fix_script "$data_dir/99-post"
    if [ $? -eq 1 ] ; then
      failed=1
    fi
  fi

  # seems to help to let steam settle
  sleep 1

  # check deps last since it may take a while
  steamtricks_fix_deps "$app_id"
  local deps=$?

  # prints directory to which it changes
  cd - > /dev/null

  if [ $removed -gt 0 ] || [ $applied -gt 0 ] || [ $deps -eq 1 ] ; then
    local status
    if [ $failed -eq 0 ] ; then
      status=success
    else
      status=failure
    fi

    local $deps_status
    if [ $deps -eq 1 ] ; then
      deps_status="installed"
    else
      deps_status="unchanged"
    fi

    local message="<h3>$app_name</h3><ul> \
      <li>result: $status</li> \
      <li>removed: $removed</li> \
      <li>applied: $applied</li> \
      <li>dependencies: $deps_status</li> \
      </ul>"

    notify FIX_APPLY "$message"
  else
    notify FIX_APPLY_NONE "No changes needed by <b>$app_name</b>"
  fi
}

streamtricks_fix_script()
{
  local script="$1"
  if [ -f "$script" ] ; then
    echo "executing $script"
    "$script"
    if [ ! $? -eq 0 ] ; then
      echo "-> script failed"
      return 1
    fi
  fi
  return 0
}

# openSUSE specific, once other distro provide equivilent this can be abstracted
steamtricks_fix_deps()
{
  echo "checking dependencies..."

  # `find -maxdepth 1` is nice, but games like dota have nothing in their root
  # directory. However this makes the check much more expensive. Until it is
  # clear this is common enough to warrant the cost, leave with maxdepth.
  # Alternatively, include in -data repo or package builds would remove cost.
  local app_id=$1
  local prefix=/tmp/steamtricks
  find . -type f -maxdepth 1 > $prefix-files
  local provides=$(/usr/lib/rpm/find-provides < $prefix-files | sort | tee $prefix-provides | wc -l)
  local requires=$(/usr/lib/rpm/find-requires < $prefix-files | sort | tee $prefix-requires | wc -l)
  local needs=$(comm -23 $prefix-requires $prefix-provides | tee $prefix-needs | wc -l)
  local sha1=$(sha1sum < $prefix-needs) # use < to avoid filename in output
  echo "-> provides: $provides, requires: $requires, needs: $needs"

  # check if previous deps differ from current and only prompt install if changed
  local cache="$CONFIG_CACHE_DIR/$app_id"
  local update=1
  if [ -f "$cache" ] && [[ "$sha1" == "$(cat "$cache")" ]] ; then
    update=0
  fi

  if [ $update -eq 1 ] ; then
    xdg-terminal '/usr/bin/env bash -c "sudo zypper in -C $(cat '$prefix-needs') && sleep 5"'
    echo "$sha1" > "$cache"
    return 1
  else
    echo "-> nothing new"
    return 0
  fi

  rm $prefix-*
}

# Many apps also ship a libstdc that causes issues in the same way the steam
# runtime version of the lib does. As such parse the config to get a list of
# library folders to search and remove such files. An example of a game that
# will not launch without this fix is Portal 2 (app 620). Unfortunately, there
# does not appear to be a method for running the script after a game has
# downloaded or before it launches so at best a steam restart will work.
remove_incompatible_files()
{
  echo "removing troublesome files..." >&2
  local IFS=$'\n' # allow for spaces in directories
  local count=0
  for dir in $*; do
    echo "-> checking $dir" >&2
    ((count+=$(find "$dir" -type f -name "libstdc*" -print -delete | tee /dev/stderr | wc -l)))
  done
  echo $count
}

# TODO replace with bootstrap phase watching
remove_incompatible_files_runtime()
{
  local count=$(remove_incompatible_files $STEAM_RUNTIME)
  if [ $count -gt 0 ] ; then
    notify CLEAN "$count troublesome file(s) removed from steam-runtime"
  fi
}

steam_content_log_watch()
{
  echo -n "waiting for steam to start..."
  local tries=0
  until pgrep -xo steam > /dev/null ; do
    if [ $((tries++)) -eq $C_STEAM_STARTUP_TIMEOUT_MAX_SECS ] ; then
     echo "failed after $C_STEAM_STARTUP_TIMEOUT_MAX_SECS seconds"
     exit 1
    fi
    sleep 1
  done
  echo "done"
  
  tail --pid $$ -fn0 "$STEAM_DIR/logs/content_log.txt" "$STEAM_DIR/logs/connection_log.txt" | \
  while read line ; do
    # steam prints CRLF into log files (issue #4646)
    # for some reason this does not work when chained above
    line=$(echo "$line" | tr -d '\r')
    
    echo $line
    
    echo "$line" | grep "state changed : Update Required,$" > /dev/null
    if [ $? = 0 ] ; then
      local parts=($line)
      steamtricks_fix_fetch ${parts[3]}
    fi

    echo "$line" | grep "state changed : Fully Installed,Update Running,$" > /dev/null
    if [ $? = 0 ] ; then
      local parts=($line)
      steamtricks_fix_apply ${parts[3]}
    fi
    
    #steam has been closed
    echo "$line" | grep "Log session ended" > /dev/null
    if [ $? = 0 ] ; then
      echo "steam quit, exit"
      pkill -F "$PID_FILE" #tail stops everything from exiting so break doesn't work.
      exit
    fi
    
  done

  echo "steam quit, exit"
}

steam_lib_replace()
{
  local replacement="$STEAM_LIB_PREFIX/$1"
  local original="$2"

  if [ ! -L "$original" ] && [ -f "$replacement" ] ; then
    rm "$original"
    ln -s "$replacement" "$original"
    echo "-> replace $original with $replacement"
  fi
}

steam_openssl_replace()
{
  echo "replacing steam-runtime openssl libraries..."
  for lib in libcrypto.so.1.0.0 libssl.so.1.0.0 ; do
    find "$STEAM_RUNTIME/i386" -name $lib | while read found
    do
      steam_lib_replace "lib/$lib" "$found"
    done

    find "$STEAM_RUNTIME/amd64" -name $lib | while read found
    do
      steam_lib_replace "lib64/$lib" "$found"
    done
  done
}

steamtricks_data_dir()
{
  # check for config override, but allow git to win
  if [ ! -z "$C_DATA_DIR" ] ; then
    STEAMTRICKS_DATA_REPO_DIR="$C_DATA_DIR"
  fi

  # automatically use development copy if running out of git tree
  if [ -d "$STEAMTRICKS_DIR/../.git" ] && [ -d "$STEAMTRICKS_DIR/../data" ] ; then
    STEAMTRICKS_DATA_REPO_DIR="$STEAMTRICKS_DIR/../data"
  fi
}

steamtricks_config()
{
  if [ ! -d "$CONFIG_DIR" ] ; then
    mkdir -p "$CONFIG_DIR"
  fi

  if [ ! -d "$CONFIG_CACHE_DIR" ] ; then
    mkdir -p "$CONFIG_CACHE_DIR"
  fi

  if [ -e "$CONFIG_RC" ] ; then
    source "$CONFIG_RC"
    if [ -z "$C_VERSION" ] || [ $C_VERSION -lt $_C_VERSION ] ; then
      C_VERSION=$_C_VERSION
      # config is already loaded, remove config and re-write
      rm "$CONFIG_RC"
    fi
  fi

  if [ ! -e "$CONFIG_RC" ] ; then
    steamtricks_config_print > "$CONFIG_RC"
  fi
}

steamtricks_config_print()
{
  echo "#!/usr/bin/env bash"
  echo "# $(date)"
  echo

  ( set -o posix ; set ) | grep ^C_
}

steamtricks_usage()
{
    
  cat <<_EOF_
Usage: $0 [options] command

Options:
-d, --daemon          Run in the background and output to log file
-s, --stop            Stop the daemon
-f, --force           Force launch by removing pid file
    --version         Print version string and exit
    --watch           Watch Steam logs for relevant activity
-h, --help            Display this message and exit

Commands:
clean                 Clean steam-runtime and steamapps directories
_EOF_
}

steamtricks_handle_option()
{
  case "$1" in
    -d|--daemon) STEAMTRICKS_DAEMON=1 ;;
    -s|--stop) STEAMTRICKS_DAEMON_STOP=1;;
    -f|--force) rm -f -- "$PID_FILE" ;;
    --version) echo "$STEAMTRICKS_VERSION"; exit 0; ;;
    --watch) STEAMTRICKS_WATCH=1 ;;
    -h|--help) steamtricks_usage ; exit 0 ;;
    -*) echo "unknown option $1" ; exit 1 ;;
    *) return 1 ;;
  esac
  return 0
}


while steamtricks_handle_option $1 ; do
  shift
done

if test "$STEAMTRICKS_WATCH" == 1 ; then
  #redirect stdout as watch daemon
  log="$CONFIG_DIR/steamtricks.log"
  exec 1<&-
  exec 1<>$log
fi

# pid file to detect already running
if [ -f "$PID_FILE" ] ; then
  #running but want to stop
  if test "$STEAMTRICKS_DAEMON_STOP" == 1 ; then
    echo "Stopping steamtricks..."
    pkill -F "$PID_FILE"
    exit 0
  fi
  
  #ignore if running watch thread
  if test "$STEAMTRICKS_WATCH" == 0 ; then
    echo "steamtricks is already running"
    exit 1
  fi
  
else
  if test "$STEAMTRICKS_DAEMON_STOP" == 1 ; then
   echo "steamtricks is not currently running"
   exit 1
  fi
fi

# initial boot
steamtricks_config

#check if daemon requested
if test "$STEAMTRICKS_DAEMON" == 1 ; then
  log="$CONFIG_DIR/steamtricks.log"
  if [ -f "$log" ] ; then
    mv "$log" "$log.1"
  fi
  
  #launch watch instance in background
  $0 --watch &
  echo $! > "$PID_FILE"
  echo "steamtricks daemon launched"
 
  exit
  
else
  remove_incompatible_files_runtime
  if test "$STEAM_OPENSSL_REPLACE" == 1 ; then
    steam_openssl_replace
  fi
fi

# watch phase
steamtricks_data_dir
if test "$STEAMTRICKS_WATCH" == 1 ; then
  trap "rm -f -- '$PID_FILE'" EXIT
  steam_content_log_watch
fi
